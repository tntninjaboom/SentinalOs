/*
 * SentinalOS Pentesting Sandbox
 * Pentagon-Level Security Isolation for Offensive Tools
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <sched.h>
#include <signal.h>
#include <pwd.h>
#include <grp.h>

#define SANDBOX_USER "pentester"
#define SANDBOX_GROUP "pentesting"
#define SANDBOX_ROOT "/var/sandbox/pentesting"
#define MAX_TOOLS 32
#define MAX_ARGS 64
#define MAX_PATH 512

/* Pentesting tool definitions */
struct pentesting_tool {
    const char *name;
    const char *binary_path;
    const char *description;
    uint32_t required_caps;
    uint8_t risk_level;        /* 1=Low, 5=Critical */
    bool network_access;
    bool filesystem_write;
    const char *allowed_targets[];
};

/* Security context for sandbox */
struct sandbox_context {
    uid_t user_id;
    gid_t group_id;
    char chroot_path[MAX_PATH];
    uint32_t capabilities;
    uint64_t memory_limit;
    uint32_t time_limit;
    bool network_isolated;
    char log_file[MAX_PATH];
};

/* Available pentesting tools */
static const struct pentesting_tool available_tools[] = {
    {
        .name = "nmap",
        .binary_path = "/usr/bin/nmap",
        .description = "Network discovery and security auditing",
        .required_caps = 0x01, /* CAP_NET_RAW */
        .risk_level = 2,
        .network_access = true,
        .filesystem_write = false,
        .allowed_targets = {"192.168.0.0/16", "10.0.0.0/8", "172.16.0.0/12", NULL}
    },
    {
        .name = "netcat",
        .binary_path = "/usr/bin/nc",
        .description = "Networking utility for reading/writing network connections",
        .required_caps = 0x00,
        .risk_level = 3,
        .network_access = true,
        .filesystem_write = false,
        .allowed_targets = {"*", NULL}
    },
    {
        .name = "wireshark",
        .binary_path = "/usr/bin/tshark",
        .description = "Network protocol analyzer",
        .required_caps = 0x01, /* CAP_NET_RAW */
        .risk_level = 2,
        .network_access = true,
        .filesystem_write = true,
        .allowed_targets = {"*", NULL}
    },
    {
        .name = "hashcat",
        .binary_path = "/usr/bin/hashcat",
        .description = "Advanced password recovery utility",
        .required_caps = 0x00,
        .risk_level = 4,
        .network_access = false,
        .filesystem_write = true,
        .allowed_targets = {NULL}
    },
    {
        .name = "john",
        .binary_path = "/usr/bin/john",
        .description = "John the Ripper password cracker",
        .required_caps = 0x00,
        .risk_level = 4,
        .network_access = false,
        .filesystem_write = true,
        .allowed_targets = {NULL}
    },
    {
        .name = "sqlmap",
        .binary_path = "/usr/bin/sqlmap",
        .description = "Automatic SQL injection and database takeover tool",
        .required_caps = 0x00,
        .risk_level = 5,
        .network_access = true,
        .filesystem_write = true,
        .allowed_targets = {"192.168.0.0/16", "10.0.0.0/8", "172.16.0.0/12", NULL}
    },
    {
        .name = "metasploit",
        .binary_path = "/opt/metasploit/msfconsole",
        .description = "Penetration testing framework",
        .required_caps = 0x01, /* CAP_NET_RAW */
        .risk_level = 5,
        .network_access = true,
        .filesystem_write = true,
        .allowed_targets = {"192.168.0.0/16", "10.0.0.0/8", "172.16.0.0/12", NULL}
    },
    {NULL, NULL, NULL, 0, 0, false, false, {NULL}} /* Sentinel */
};

/* Logging functions */
static void log_sandbox_event(const char *event, const char *details) {
    FILE *log = fopen("/var/log/pentesting_sandbox.log", "a");
    if (log) {
        time_t now = time(NULL);
        char *time_str = ctime(&now);
        time_str[strlen(time_str) - 1] = '\0'; /* Remove newline */
        
        fprintf(log, "[%s] %s: %s\n", time_str, event, details ? details : "");
        fclose(log);
    }
    
    printf("[SANDBOX] %s: %s\n", event, details ? details : "");
}

/* Security validation */
static int validate_target(const struct pentesting_tool *tool, const char *target) {
    if (!tool->allowed_targets[0]) {
        return 1; /* No restrictions */
    }
    
    for (int i = 0; tool->allowed_targets[i]; i++) {
        if (strcmp(tool->allowed_targets[i], "*") == 0) {
            return 1; /* Wildcard allowed */
        }
        
        /* Simple subnet check - in production, use proper IP validation */
        if (strstr(target, tool->allowed_targets[i])) {
            return 1;
        }
    }
    
    return 0; /* Target not allowed */
}

/* Setup sandbox environment */
static int setup_sandbox(struct sandbox_context *ctx) {
    log_sandbox_event("SETUP_START", "Initializing pentesting sandbox");
    
    /* Create sandbox directory structure */
    if (mkdir(ctx->chroot_path, 0755) != 0 && errno != EEXIST) {
        log_sandbox_event("SETUP_ERROR", "Failed to create sandbox directory");
        return -1;
    }
    
    /* Create necessary subdirectories */
    char path[MAX_PATH];
    const char *dirs[] = {"bin", "usr", "tmp", "var", "proc", "dev", NULL};
    
    for (int i = 0; dirs[i]; i++) {
        snprintf(path, sizeof(path), "%s/%s", ctx->chroot_path, dirs[i]);
        mkdir(path, 0755);
    }
    
    /* Mount necessary filesystems */
    snprintf(path, sizeof(path), "%s/proc", ctx->chroot_path);
    if (mount("proc", path, "proc", MS_NOSUID | MS_NOEXEC | MS_NODEV, NULL) != 0) {
        log_sandbox_event("SETUP_WARNING", "Failed to mount /proc in sandbox");
    }
    
    snprintf(path, sizeof(path), "%s/tmp", ctx->chroot_path);
    if (mount("tmpfs", path, "tmpfs", MS_NOSUID | MS_NOEXEC | MS_NODEV, "size=100M") != 0) {
        log_sandbox_event("SETUP_WARNING", "Failed to mount /tmp in sandbox");
    }
    
    log_sandbox_event("SETUP_COMPLETE", "Sandbox environment ready");
    return 0;
}

/* Drop privileges and enter sandbox */
static int enter_sandbox(const struct sandbox_context *ctx) {
    log_sandbox_event("ENTER_START", "Entering sandbox environment");
    
    /* Create new namespaces for isolation */
    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUTS) != 0) {
        log_sandbox_event("ENTER_ERROR", "Failed to create namespaces");
        return -1;
    }
    
    /* Change root to sandbox */
    if (chroot(ctx->chroot_path) != 0) {
        log_sandbox_event("ENTER_ERROR", "Failed to chroot to sandbox");
        return -1;
    }
    
    if (chdir("/") != 0) {
        log_sandbox_event("ENTER_ERROR", "Failed to change directory in sandbox");
        return -1;
    }
    
    /* Drop privileges */
    if (setgid(ctx->group_id) != 0 || setuid(ctx->user_id) != 0) {
        log_sandbox_event("ENTER_ERROR", "Failed to drop privileges");
        return -1;
    }
    
    /* Verify privilege drop */
    if (getuid() == 0 || geteuid() == 0) {
        log_sandbox_event("ENTER_ERROR", "Still running as root after privilege drop");
        return -1;
    }
    
    log_sandbox_event("ENTER_COMPLETE", "Successfully entered sandbox");
    return 0;
}

/* Execute tool in sandbox */
static int execute_tool(const struct pentesting_tool *tool, char *argv[]) {
    char details[512];
    snprintf(details, sizeof(details), "Executing %s", tool->name);
    log_sandbox_event("EXEC_START", details);
    
    /* Set resource limits */
    struct rlimit limit;
    
    /* Memory limit (1GB) */
    limit.rlim_cur = limit.rlim_max = 1024 * 1024 * 1024;
    setrlimit(RLIMIT_AS, &limit);
    
    /* CPU time limit (1 hour) */
    limit.rlim_cur = limit.rlim_max = 3600;
    setrlimit(RLIMIT_CPU, &limit);
    
    /* File size limit (100MB) */
    limit.rlim_cur = limit.rlim_max = 100 * 1024 * 1024;
    setrlimit(RLIMIT_FSIZE, &limit);
    
    /* Execute the tool */
    execv(tool->binary_path, argv);
    
    /* If we get here, exec failed */
    log_sandbox_event("EXEC_ERROR", "Failed to execute tool");
    return -1;
}

/* Find tool by name */
static const struct pentesting_tool *find_tool(const char *name) {
    for (int i = 0; available_tools[i].name; i++) {
        if (strcmp(available_tools[i].name, name) == 0) {
            return &available_tools[i];
        }
    }
    return NULL;
}

/* Print available tools */
static void print_tools(void) {
    printf("\nAvailable Pentesting Tools:\n");
    printf("==========================\n\n");
    
    for (int i = 0; available_tools[i].name; i++) {
        const struct pentesting_tool *tool = &available_tools[i];
        
        printf("Name: %s\n", tool->name);
        printf("Description: %s\n", tool->description);
        printf("Risk Level: %d/5\n", tool->risk_level);
        printf("Network Access: %s\n", tool->network_access ? "Yes" : "No");
        printf("Filesystem Write: %s\n", tool->filesystem_write ? "Yes" : "No");
        
        if (tool->allowed_targets[0]) {
            printf("Allowed Targets: ");
            for (int j = 0; tool->allowed_targets[j]; j++) {
                printf("%s%s", j > 0 ? "," : "", tool->allowed_targets[j]);
            }
            printf("\n");
        }
        
        printf("\n");
    }
}

/* Main function */
int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("SentinalOS Pentesting Sandbox v1.0\n");
        printf("Pentagon-Level Security Isolation for Offensive Tools\n\n");
        printf("Usage: %s <tool_name> [tool_arguments...]\n", argv[0]);
        printf("       %s --list (show available tools)\n", argv[0]);
        print_tools();
        return 1;
    }
    
    if (strcmp(argv[1], "--list") == 0) {
        print_tools();
        return 0;
    }
    
    /* Security check - must be run as root initially */
    if (getuid() != 0) {
        fprintf(stderr, "Error: Sandbox must be run as root for proper isolation\n");
        return 1;
    }
    
    /* Find the requested tool */
    const struct pentesting_tool *tool = find_tool(argv[1]);
    if (!tool) {
        fprintf(stderr, "Error: Tool '%s' not found\n", argv[1]);
        printf("Run '%s --list' to see available tools\n", argv[0]);
        return 1;
    }
    
    /* Security validation */
    if (tool->risk_level >= 4) {
        printf("WARNING: This tool has a HIGH risk level (%d/5)\n", tool->risk_level);
        printf("Tool: %s\n", tool->description);
        printf("Continue? (y/N): ");
        
        char response;
        if (scanf("%c", &response) != 1 || (response != 'y' && response != 'Y')) {
            printf("Operation cancelled\n");
            return 0;
        }
    }
    
    /* Validate target if specified */
    if (argc > 2 && !validate_target(tool, argv[2])) {
        fprintf(stderr, "Error: Target '%s' not allowed for tool '%s'\n", argv[2], tool->name);
        return 1;
    }
    
    /* Setup sandbox context */
    struct sandbox_context ctx = {
        .user_id = 1000,  /* pentester user */
        .group_id = 1000, /* pentesting group */
        .capabilities = tool->required_caps,
        .memory_limit = 1024 * 1024 * 1024, /* 1GB */
        .time_limit = 3600, /* 1 hour */
        .network_isolated = !tool->network_access
    };
    
    snprintf(ctx.chroot_path, sizeof(ctx.chroot_path), "%s/%s", SANDBOX_ROOT, tool->name);
    snprintf(ctx.log_file, sizeof(ctx.log_file), "/var/log/pentesting_%s.log", tool->name);
    
    /* Setup sandbox environment */
    if (setup_sandbox(&ctx) != 0) {
        fprintf(stderr, "Failed to setup sandbox\n");
        return 1;
    }
    
    /* Fork for sandboxed execution */
    pid_t pid = fork();
    if (pid == 0) {
        /* Child process - enter sandbox and execute tool */
        if (enter_sandbox(&ctx) != 0) {
            exit(1);
        }
        
        /* Execute the tool */
        execute_tool(tool, &argv[1]);
        exit(1); /* Should not reach here */
    } else if (pid > 0) {
        /* Parent process - monitor execution */
        int status;
        
        log_sandbox_event("MONITOR_START", "Monitoring sandboxed execution");
        
        if (waitpid(pid, &status, 0) == -1) {
            log_sandbox_event("MONITOR_ERROR", "Failed to wait for child process");
            return 1;
        }
        
        if (WIFEXITED(status)) {
            char details[256];
            snprintf(details, sizeof(details), "Tool exited with code %d", WEXITSTATUS(status));
            log_sandbox_event("MONITOR_COMPLETE", details);
        } else if (WIFSIGNALED(status)) {
            char details[256];
            snprintf(details, sizeof(details), "Tool terminated by signal %d", WTERMSIG(status));
            log_sandbox_event("MONITOR_TERMINATED", details);
        }
        
        return WEXITSTATUS(status);
    } else {
        log_sandbox_event("FORK_ERROR", "Failed to fork for sandboxed execution");
        return 1;
    }
}